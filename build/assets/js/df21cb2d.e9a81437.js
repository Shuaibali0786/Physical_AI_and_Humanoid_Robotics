"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[655],{6245:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>a,contentTitle:()=>t,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"modules/ros2-nervous-system/basics/nodes-topics-services","title":"ROS 2 Nodes, Topics, and Services","description":"Nodes","source":"@site/docs/modules/ros2-nervous-system/basics/nodes-topics-services.md","sourceDirName":"modules/ros2-nervous-system/basics","slug":"/modules/ros2-nervous-system/basics/nodes-topics-services","permalink":"/docs/modules/ros2-nervous-system/basics/nodes-topics-services","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"modules","previous":{"title":"ROS 2 Basics & Middleware","permalink":"/docs/modules/ros2-nervous-system/basics/"},"next":{"title":"Communication Patterns in ROS 2","permalink":"/docs/modules/ros2-nervous-system/basics/communication-patterns"}}');var r=n(4848),c=n(8453);const o={},t="ROS 2 Nodes, Topics, and Services",a={},l=[{value:"Nodes",id:"nodes",level:2},{value:"Creating a Node",id:"creating-a-node",level:3},{value:"Topics and Message Passing",id:"topics-and-message-passing",level:2},{value:"Key Concepts:",id:"key-concepts",level:3},{value:"Communication Pattern:",id:"communication-pattern",level:3},{value:"Services",id:"services",level:2},{value:"Key Concepts:",id:"key-concepts-1",level:3},{value:"Communication Pattern:",id:"communication-pattern-1",level:3},{value:"Practical Example: Publisher-Subscriber",id:"practical-example-publisher-subscriber",level:2}];function d(e){const s={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,c.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.header,{children:(0,r.jsx)(s.h1,{id:"ros-2-nodes-topics-and-services",children:"ROS 2 Nodes, Topics, and Services"})}),"\n",(0,r.jsx)(s.h2,{id:"nodes",children:"Nodes"}),"\n",(0,r.jsx)(s.p,{children:"A node is a process that performs computation. Nodes are the fundamental building blocks of a ROS 2 system. Each node is designed to perform a specific task and communicates with other nodes through topics, services, and actions."}),"\n",(0,r.jsx)(s.h3,{id:"creating-a-node",children:"Creating a Node"}),"\n",(0,r.jsxs)(s.p,{children:["In ROS 2, nodes are typically created using client libraries like ",(0,r.jsx)(s.code,{children:"rclpy"})," for Python or ",(0,r.jsx)(s.code,{children:"rclcpp"})," for C++. Each node must have a unique name within its namespace."]}),"\n",(0,r.jsx)(s.p,{children:"Key characteristics of nodes:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Each node runs in its own process"}),"\n",(0,r.jsx)(s.li,{children:"Nodes can be written in different programming languages"}),"\n",(0,r.jsx)(s.li,{children:"Nodes can be started and stopped independently"}),"\n",(0,r.jsx)(s.li,{children:"Nodes must be part of a ROS 2 graph to communicate"}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"topics-and-message-passing",children:"Topics and Message Passing"}),"\n",(0,r.jsx)(s.p,{children:"Topics enable asynchronous communication between nodes through a publish-subscribe model. Publishers send messages to a topic, and subscribers receive messages from the topic."}),"\n",(0,r.jsx)(s.h3,{id:"key-concepts",children:"Key Concepts:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Publishers"}),": Nodes that send data to a topic"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Subscribers"}),": Nodes that receive data from a topic"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Messages"}),": Data structures that are passed between nodes"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Quality of Service (QoS)"}),": Settings that define communication behavior"]}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"communication-pattern",children:"Communication Pattern:"}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsx)(s.li,{children:"A publisher node sends messages to a named topic"}),"\n",(0,r.jsx)(s.li,{children:"The ROS 2 middleware routes messages to all subscribers of that topic"}),"\n",(0,r.jsx)(s.li,{children:"Subscribers receive messages asynchronously"}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"services",children:"Services"}),"\n",(0,r.jsx)(s.p,{children:"Services provide synchronous request-response communication between nodes. A client sends a request to a service, and the service sends back a response."}),"\n",(0,r.jsx)(s.h3,{id:"key-concepts-1",children:"Key Concepts:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Service Server"}),": Node that provides a service"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Service Client"}),": Node that uses a service"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Service Interface"}),": Defines the request and response message types"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Synchronous"}),": The client waits for the response before continuing"]}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"communication-pattern-1",children:"Communication Pattern:"}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsx)(s.li,{children:"A client sends a request to a service"}),"\n",(0,r.jsx)(s.li,{children:"The service processes the request"}),"\n",(0,r.jsx)(s.li,{children:"The service sends back a response"}),"\n",(0,r.jsx)(s.li,{children:"The client receives the response and continues"}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"practical-example-publisher-subscriber",children:"Practical Example: Publisher-Subscriber"}),"\n",(0,r.jsx)(s.p,{children:"In the next section, we'll implement a simple publisher-subscriber example that demonstrates these concepts in practice."})]})}function h(e={}){const{wrapper:s}={...(0,c.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>o,x:()=>t});var i=n(6540);const r={},c=i.createContext(r);function o(e){const s=i.useContext(c);return i.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function t(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(c.Provider,{value:s},e.children)}}}]);