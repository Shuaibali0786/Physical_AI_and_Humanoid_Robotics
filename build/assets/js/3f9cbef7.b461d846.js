"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[830],{8453:(e,n,r)=>{r.d(n,{R:()=>t,x:()=>s});var a=r(6540);const i={},o=a.createContext(i);function t(e){const n=a.useContext(o);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),a.createElement(o.Provider,{value:n},e.children)}},9043:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>t,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"module3-isaac/nav2-planning","title":"Nav2 Path Planning for Bipedal Humanoids","description":"Introduction to Navigation for Humanoid Robots","source":"@site/docs/module3-isaac/nav2-planning.md","sourceDirName":"module3-isaac","slug":"/module3-isaac/nav2-planning","permalink":"/docs/module3-isaac/nav2-planning","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"modules","previous":{"title":"Isaac ROS: Hardware-Accelerated VSLAM","permalink":"/docs/module3-isaac/isaac-ros-vslam"},"next":{"title":"Perception and Manipulation with Isaac Sim","permalink":"/docs/module3-isaac/perception-manipulation"}}');var i=r(4848),o=r(8453);const t={},s="Nav2 Path Planning for Bipedal Humanoids",l={},c=[{value:"Introduction to Navigation for Humanoid Robots",id:"introduction-to-navigation-for-humanoid-robots",level:2},{value:"Nav2 Architecture Overview",id:"nav2-architecture-overview",level:2},{value:"Navigation Stack Components",id:"navigation-stack-components",level:3},{value:"Humanoid-Specific Considerations",id:"humanoid-specific-considerations",level:3},{value:"Nav2 Core Components",id:"nav2-core-components",level:2},{value:"Global Planner",id:"global-planner",level:3},{value:"Local Planner",id:"local-planner",level:3},{value:"Humanoid Path Planning Algorithms",id:"humanoid-path-planning-algorithms",level:2},{value:"Footstep Planning",id:"footstep-planning",level:3},{value:"Footstep Planner Implementation",id:"footstep-planner-implementation",level:4},{value:"Balance-Aware Planning",id:"balance-aware-planning",level:4},{value:"3D Navigation Planning",id:"3d-navigation-planning",level:3},{value:"Terrain Analysis",id:"terrain-analysis",level:4},{value:"Nav2 Behavior Trees for Humanoids",id:"nav2-behavior-trees-for-humanoids",level:2},{value:"Custom Behavior Tree Nodes",id:"custom-behavior-tree-nodes",level:3},{value:"Humanoid-Specific Actions",id:"humanoid-specific-actions",level:3},{value:"Navigation Parameters for Humanoids",id:"navigation-parameters-for-humanoids",level:2},{value:"Configuration File",id:"configuration-file",level:3},{value:"Humanoid-Specific Navigation Challenges",id:"humanoid-specific-navigation-challenges",level:2},{value:"Balance and Stability",id:"balance-and-stability",level:3},{value:"Center of Mass Management",id:"center-of-mass-management",level:4},{value:"Dynamic Stability",id:"dynamic-stability",level:4},{value:"Gait Integration",id:"gait-integration",level:3},{value:"Walking Pattern Generation",id:"walking-pattern-generation",level:4},{value:"Simulation and Testing",id:"simulation-and-testing",level:2},{value:"Gazebo Integration",id:"gazebo-integration",level:3},{value:"Isaac Sim Integration",id:"isaac-sim-integration",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Real-time Considerations",id:"real-time-considerations",level:3},{value:"Computational Efficiency",id:"computational-efficiency",level:3},{value:"Safety and Recovery",id:"safety-and-recovery",level:2},{value:"Emergency Procedures",id:"emergency-procedures",level:3},{value:"Recovery Behaviors",id:"recovery-behaviors",level:3},{value:"Integration with Isaac Sim",id:"integration-with-isaac-sim",level:2},{value:"Simulation-Based Training",id:"simulation-based-training",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"nav2-path-planning-for-bipedal-humanoids",children:"Nav2 Path Planning for Bipedal Humanoids"})}),"\n",(0,i.jsx)(n.h2,{id:"introduction-to-navigation-for-humanoid-robots",children:"Introduction to Navigation for Humanoid Robots"}),"\n",(0,i.jsx)(n.p,{children:"Navigation for bipedal humanoid robots presents unique challenges compared to wheeled or tracked robots. The complex kinematics, balance requirements, and anthropomorphic form factor require specialized path planning approaches that account for the robot's unique locomotion capabilities and constraints."}),"\n",(0,i.jsx)(n.h2,{id:"nav2-architecture-overview",children:"Nav2 Architecture Overview"}),"\n",(0,i.jsx)(n.h3,{id:"navigation-stack-components",children:"Navigation Stack Components"}),"\n",(0,i.jsx)(n.p,{children:"Nav2 (Navigation 2) is ROS 2's state-of-the-art navigation framework that provides:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Behavior Trees"}),": Flexible task execution"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Plugin Architecture"}),": Modular components"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Recovery Behaviors"}),": Robust failure handling"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Safety Features"}),": Collision avoidance and emergency stops"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"humanoid-specific-considerations",children:"Humanoid-Specific Considerations"}),"\n",(0,i.jsx)(n.p,{children:"Bipedal navigation requires modifications to standard Nav2 components:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Footstep planning"}),": Discrete foot placement"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Balance constraints"}),": Maintaining stability"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Step height limitations"}),": Obstacle clearance"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Turning radius"}),": Limited by leg span"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Ground clearance"}),": Minimum step height"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"nav2-core-components",children:"Nav2 Core Components"}),"\n",(0,i.jsx)(n.h3,{id:"global-planner",children:"Global Planner"}),"\n",(0,i.jsx)(n.p,{children:"The global planner creates a path from start to goal:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Example custom global planner for humanoid robots\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom nav2_msgs.action import NavigateToPose\r\nfrom nav2_msgs.srv import LoadMap\r\nfrom geometry_msgs.msg import PoseStamped\r\nfrom nav_msgs.msg import Path\r\n\r\nclass HumanoidGlobalPlanner(Node):\r\n    def __init__(self):\r\n        super().__init__('humanoid_global_planner')\r\n\r\n        # Initialize with humanoid-specific parameters\r\n        self.foot_separation = self.declare_parameter('foot_separation', 0.3).value\r\n        self.step_height = self.declare_parameter('max_step_height', 0.1).value\r\n        self.turn_radius = self.declare_parameter('min_turn_radius', 0.5).value\r\n\r\n        # Create path publisher\r\n        self.path_pub = self.create_publisher(Path, 'global_plan', 1)\r\n\r\n    def plan_path(self, start_pose, goal_pose):\r\n        # Custom planning considering humanoid constraints\r\n        path = self.calculate_humanoid_path(start_pose, goal_pose)\r\n        self.path_pub.publish(path)\r\n        return path\r\n\r\n    def calculate_humanoid_path(self, start, goal):\r\n        # Implement humanoid-aware path planning\r\n        # Consider step constraints, balance, and foot placement\r\n        pass\n"})}),"\n",(0,i.jsx)(n.h3,{id:"local-planner",children:"Local Planner"}),"\n",(0,i.jsx)(n.p,{children:"The local planner executes the global plan while avoiding obstacles:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Example humanoid local planner\r\nfrom nav2_core.local_planner import LocalPlanner\r\nfrom geometry_msgs.msg import Twist\r\nfrom sensor_msgs.msg import LaserScan\r\n\r\nclass HumanoidLocalPlanner(LocalPlanner):\r\n    def __init__(self):\r\n        self.step_frequency = 0.5  # Steps per second\r\n        self.balance_margin = 0.1  # Safety margin for balance\r\n\r\n    def compute_velocity_commands(self, pose, velocity, goal_checker):\r\n        # Calculate humanoid-appropriate velocity commands\r\n        # considering balance and step constraints\r\n        cmd_vel = Twist()\r\n\r\n        # Convert to footstep commands\r\n        footstep_commands = self.calculate_footsteps(pose, velocity)\r\n\r\n        return cmd_vel, footstep_commands\n"})}),"\n",(0,i.jsx)(n.h2,{id:"humanoid-path-planning-algorithms",children:"Humanoid Path Planning Algorithms"}),"\n",(0,i.jsx)(n.h3,{id:"footstep-planning",children:"Footstep Planning"}),"\n",(0,i.jsx)(n.h4,{id:"footstep-planner-implementation",children:"Footstep Planner Implementation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import numpy as np\r\nfrom geometry_msgs.msg import Point\r\n\r\nclass FootstepPlanner:\r\n    def __init__(self):\r\n        self.foot_width = 0.15  # meters\r\n        self.foot_length = 0.30  # meters\r\n        self.max_step_length = 0.4  # meters\r\n        self.max_step_width = 0.6  # meters\r\n        self.max_step_rotation = np.pi / 4  # radians\r\n\r\n    def plan_footsteps(self, start_pose, goal_pose):\r\n        footsteps = []\r\n\r\n        # Calculate intermediate steps\r\n        current_pose = start_pose\r\n        while not self.reached_goal(current_pose, goal_pose):\r\n            next_footstep = self.calculate_next_footstep(current_pose, goal_pose)\r\n            footsteps.append(next_footstep)\r\n            current_pose = next_footstep\r\n\r\n        return footsteps\r\n\r\n    def calculate_next_footstep(self, current, goal):\r\n        # Calculate next footstep considering:\r\n        # - Maximum step length/width\r\n        # - Balance constraints\r\n        # - Obstacle avoidance\r\n        # - Smooth trajectory\r\n        pass\n"})}),"\n",(0,i.jsx)(n.h4,{id:"balance-aware-planning",children:"Balance-Aware Planning"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Zero Moment Point (ZMP)"}),": Maintain balance during locomotion"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Capture Point"}),": Ensure stable stopping positions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Support Polygon"}),": Maintain feet within stable region"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Dynamic Balance"}),": Account for momentum during movement"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"3d-navigation-planning",children:"3D Navigation Planning"}),"\n",(0,i.jsx)(n.h4,{id:"terrain-analysis",children:"Terrain Analysis"}),"\n",(0,i.jsx)(n.p,{children:"For humanoid robots navigating complex terrain:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class TerrainAnalyzer:\r\n    def __init__(self):\r\n        self.max_climb_height = 0.15  # meters\r\n        self.min_step_height = 0.02  # meters\r\n        self.max_slope = 0.3  # ratio (1:3)\r\n\r\n    def analyze_terrain(self, elevation_map):\r\n        # Analyze terrain for humanoid traversability\r\n        traversable_regions = []\r\n\r\n        for cell in elevation_map:\r\n            if self.is_traversable(cell):\r\n                traversable_regions.append(cell)\r\n\r\n        return traversable_regions\r\n\r\n    def is_traversable(self, cell):\r\n        # Check if cell is traversable for humanoid\r\n        # considering step height, slope, and surface properties\r\n        pass\n"})}),"\n",(0,i.jsx)(n.h2,{id:"nav2-behavior-trees-for-humanoids",children:"Nav2 Behavior Trees for Humanoids"}),"\n",(0,i.jsx)(n.h3,{id:"custom-behavior-tree-nodes",children:"Custom Behavior Tree Nodes"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",children:'\x3c!-- Example behavior tree for humanoid navigation --\x3e\r\n<root main_tree_to_execute="MainTree">\r\n    <BehaviorTree ID="MainTree">\r\n        <PipelineSequence name="navigate_with_recovery">\r\n            <RecoveryNode number_of_retries="2" name="global_plan_with_recovery">\r\n                <GlobalPlanner goal="{goal}" path="{path}" planner_id="humanoid_global_planner"/>\r\n                <RecoveryNode number_of_retries="2" name="global_plan_backup">\r\n                    <BackUp distance="0.3" backup_speed="0.1"/>\r\n                </RecoveryNode>\r\n            </RecoveryNode>\r\n\r\n            <RecoveryNode number_of_retries="3" name="local_plan_with_recovery">\r\n                <HumanoidController path="{path}" velocity="{cmd_vel}"/>\r\n                <RecoveryNode number_of_retries="2" name="local_plan_backup">\r\n                    <Wait wait_duration="2"/>\r\n                </RecoveryNode>\r\n            </RecoveryNode>\r\n\r\n            <RecoveryNode number_of_retries="2" name="smooth_stop">\r\n                <SmoothStop deceleration="0.5"/>\r\n            </RecoveryNode>\r\n        </PipelineSequence>\r\n    </BehaviorTree>\r\n</root>\n'})}),"\n",(0,i.jsx)(n.h3,{id:"humanoid-specific-actions",children:"Humanoid-Specific Actions"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Footstep execution"}),": Execute discrete foot placements"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Balance adjustment"}),": Adjust center of mass during movement"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Step timing"}),": Coordinate with robot's gait cycle"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Posture control"}),": Maintain stable posture during navigation"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"navigation-parameters-for-humanoids",children:"Navigation Parameters for Humanoids"}),"\n",(0,i.jsx)(n.h3,{id:"configuration-file",children:"Configuration File"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# humanoid_navigation_params.yaml\r\namcl:\r\n  ros__parameters:\r\n    use_sim_time: False\r\n    alpha1: 0.2\r\n    alpha2: 0.2\r\n    alpha3: 0.2\r\n    alpha4: 0.2\r\n    alpha5: 0.2\r\n    base_frame_id: "base_footprint"\r\n    beam_skip_distance: 0.5\r\n    beam_skip_error_threshold: 0.9\r\n    beam_skip_threshold: 0.3\r\n    do_beamskip: false\r\n    global_frame_id: "map"\r\n    lambda_short: 0.1\r\n    laser_likelihood_max_dist: 2.0\r\n    laser_max_range: 10.0\r\n    laser_min_range: -1.0\r\n    laser_model_type: "likelihood_field"\r\n    max_beams: 60\r\n    max_particles: 2000\r\n    min_particles: 500\r\n    odom_frame_id: "odom"\r\n    pf_err: 0.05\r\n    pf_z: 0.99\r\n    recovery_alpha_fast: 0.0\r\n    recovery_alpha_slow: 0.0\r\n    resample_interval: 1\r\n    robot_model_type: "nav2_amcl::DifferentialMotionModel"\r\n    save_pose_rate: 0.5\r\n    set_initial_pose: false\r\n    sigma_hit: 0.2\r\n    tf_broadcast: true\r\n    transform_tolerance: 1.0\r\n    update_min_a: 0.2\r\n    update_min_d: 0.25\r\n    z_hit: 0.5\r\n    z_max: 0.05\r\n    z_rand: 0.5\r\n    z_short: 0.05\r\n\r\nbt_navigator:\r\n  ros__parameters:\r\n    use_sim_time: False\r\n    global_frame: "map"\r\n    robot_base_frame: "base_link"\r\n    odom_topic: "odom"\r\n    bt_loop_duration: 10\r\n    default_server_timeout: 20\r\n    enable_groot_monitoring: True\r\n    groot_zmq_publisher_port: 1666\r\n    groot_zmq_server_port: 1667\r\n    # Note: these are default recovery behaviors\r\n    # For humanoid robots, customize these to include balance recovery\r\n    navigate_to_pose:\r\n      plugin: "nav2_bt_navigator/navigate_to_pose_planner_bt_node"\r\n      to_pose_node_names: ["compute_path_to_pose", "follow_path"]\r\n\r\ncontroller_server:\r\n  ros__parameters:\r\n    use_sim_time: False\r\n    controller_frequency: 20.0\r\n    min_x_velocity_threshold: 0.001\r\n    min_y_velocity_threshold: 0.001\r\n    min_theta_velocity_threshold: 0.001\r\n    progress_checker_plugin: "progress_checker"\r\n    goal_checker_plugin: "goal_checker"\r\n    controller_plugins: ["FollowPath"]\r\n\r\n    # Humanoid-specific controller\r\n    FollowPath:\r\n      plugin: "nav2_mppi_controller::MPPICtrl"\r\n      time_steps: 25\r\n      dt: 0.2\r\n      vx_samples: 25\r\n      vy_samples: 5\r\n      wz_samples: 25\r\n      rollout_samples: 1\r\n      control_horizon: 2\r\n      prediction_horizon: 10\r\n      # Humanoid-specific parameters\r\n      max_speed: 0.3  # Lower for stability\r\n      min_speed: 0.05\r\n      max_accel: 0.2  # Conservative acceleration for balance\r\n      max_decel: 0.5\r\n\r\n# Humanoid-specific parameters\r\nhumanoid_navigation:\r\n  ros__parameters:\r\n    # Step planning parameters\r\n    step_height: 0.05\r\n    step_length: 0.3\r\n    step_width: 0.4\r\n    step_frequency: 0.5\r\n    # Balance parameters\r\n    balance_margin: 0.1\r\n    zmp_tolerance: 0.05\r\n    # Safety parameters\r\n    foot_separation: 0.3\r\n    turn_radius: 0.5\r\n    min_obstacle_clearance: 0.3\n'})}),"\n",(0,i.jsx)(n.h2,{id:"humanoid-specific-navigation-challenges",children:"Humanoid-Specific Navigation Challenges"}),"\n",(0,i.jsx)(n.h3,{id:"balance-and-stability",children:"Balance and Stability"}),"\n",(0,i.jsx)(n.h4,{id:"center-of-mass-management",children:"Center of Mass Management"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class BalanceController:\r\n    def __init__(self):\r\n        self.com_height = 0.8  # Center of mass height\r\n        self.support_polygon = self.calculate_support_polygon()\r\n\r\n    def maintain_balance(self, desired_motion):\r\n        # Calculate required center of mass adjustments\r\n        # to maintain balance during navigation\r\n        com_adjustment = self.calculate_com_adjustment(desired_motion)\r\n        return com_adjustment\r\n\r\n    def calculate_support_polygon(self):\r\n        # Calculate support polygon based on foot positions\r\n        # For bipedal robots, this changes with each step\r\n        pass\n"})}),"\n",(0,i.jsx)(n.h4,{id:"dynamic-stability",children:"Dynamic Stability"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"ZMP control"}),": Maintain zero moment point within support polygon"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Capture point"}),": Ensure robot can stop safely from current state"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Angular momentum"}),": Control body rotation during locomotion"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Step timing"}),": Coordinate steps with balance requirements"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"gait-integration",children:"Gait Integration"}),"\n",(0,i.jsx)(n.h4,{id:"walking-pattern-generation",children:"Walking Pattern Generation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class GaitPlanner:\r\n    def __init__(self):\r\n        self.step_duration = 1.0  # seconds per step\r\n        self.double_support_ratio = 0.1  # 10% double support\r\n        self.swing_height = 0.05  # meters\r\n\r\n    def generate_gait_pattern(self, linear_vel, angular_vel):\r\n        # Generate walking pattern based on desired velocity\r\n        # considering humanoid kinematic constraints\r\n        gait_pattern = {\r\n            'step_length': self.calculate_step_length(linear_vel),\r\n            'step_frequency': self.calculate_step_frequency(linear_vel),\r\n            'step_width': self.calculate_step_width(angular_vel),\r\n            'swing_trajectory': self.calculate_swing_trajectory()\r\n        }\r\n        return gait_pattern\n"})}),"\n",(0,i.jsx)(n.h2,{id:"simulation-and-testing",children:"Simulation and Testing"}),"\n",(0,i.jsx)(n.h3,{id:"gazebo-integration",children:"Gazebo Integration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",children:'\x3c!-- Example Gazebo plugin for humanoid navigation testing --\x3e\r\n<gazebo>\r\n  <plugin name="humanoid_nav_plugin" filename="libgazebo_ros_nav.so">\r\n    <ros>\r\n      <namespace>/humanoid_robot</namespace>\r\n      <remapping>cmd_vel:=navigation/cmd_vel</remapping>\r\n      <remapping>odometry:=odom</remapping>\r\n    </ros>\r\n    <update_rate>30</update_rate>\r\n    <command_topic>cmd_vel</command_topic>\r\n    <odometry_topic>odom</odometry_topic>\r\n    <odometry_frame>odom</odometry_frame>\r\n    <robot_base_frame>base_footprint</robot_base_frame>\r\n    <publish_odom>true</publish_odom>\r\n    <publish_odom_tf>true</publish_odom_tf>\r\n  </plugin>\r\n</gazebo>\n'})}),"\n",(0,i.jsx)(n.h3,{id:"isaac-sim-integration",children:"Isaac Sim Integration"}),"\n",(0,i.jsx)(n.p,{children:"Leverage Isaac Sim's realistic physics for navigation testing:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Physics accuracy"}),": Realistic ground contact and friction"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Sensor simulation"}),": Accurate perception sensor models"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Environment complexity"}),": Complex indoor and outdoor scenes"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Multi-robot scenarios"}),": Test navigation in crowded environments"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,i.jsx)(n.h3,{id:"real-time-considerations",children:"Real-time Considerations"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class RealTimeNavigator:\r\n    def __init__(self):\r\n        self.planning_rate = 10.0  # Hz\r\n        self.control_rate = 50.0  # Hz\r\n        self.max_planning_time = 0.1  # seconds\r\n\r\n    def execute_navigation_cycle(self):\r\n        # Plan path with time constraints\r\n        start_time = self.get_clock().now()\r\n        path = self.plan_path()\r\n        plan_time = (self.get_clock().now() - start_time).nanoseconds / 1e9\r\n\r\n        if plan_time > self.max_planning_time:\r\n            self.get_logger().warn('Planning exceeded time limit')\r\n\r\n        # Execute with real-time constraints\r\n        self.execute_path(path)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"computational-efficiency",children:"Computational Efficiency"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Hierarchical planning"}),": Coarse-to-fine path planning"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Predictive planning"}),": Plan ahead during execution"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Parallel processing"}),": Utilize multi-core processors"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"GPU acceleration"}),": Use Isaac ROS for perception tasks"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"safety-and-recovery",children:"Safety and Recovery"}),"\n",(0,i.jsx)(n.h3,{id:"emergency-procedures",children:"Emergency Procedures"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class SafetyController:\r\n    def __init__(self):\r\n        self.emergency_stop_distance = 0.3  # meters\r\n        self.balance_threshold = 0.2  # radians\r\n\r\n    def check_safety_conditions(self):\r\n        # Check for emergency conditions\r\n        if self.detect_imminent_collision():\r\n            self.execute_emergency_stop()\r\n        elif self.detect_balance_loss():\r\n            self.execute_balance_recovery()\r\n\r\n    def execute_emergency_stop(self):\r\n        # Execute safe stopping procedure\r\n        # Gradually reduce speed to avoid falling\r\n        pass\n"})}),"\n",(0,i.jsx)(n.h3,{id:"recovery-behaviors",children:"Recovery Behaviors"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Obstacle recovery"}),": Navigate around unexpected obstacles"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Balance recovery"}),": Recover from balance disturbances"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Localization recovery"}),": Re-establish position when lost"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Communication recovery"}),": Handle sensor or communication failures"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"integration-with-isaac-sim",children:"Integration with Isaac Sim"}),"\n",(0,i.jsx)(n.h3,{id:"simulation-based-training",children:"Simulation-Based Training"}),"\n",(0,i.jsx)(n.p,{children:"Use Isaac Sim for navigation training:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Synthetic environments"}),": Train in diverse simulated worlds"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Domain randomization"}),": Improve real-world transfer"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Large-scale testing"}),": Validate navigation in thousands of scenarios"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Safety validation"}),": Test dangerous scenarios safely in simulation"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Nav2 path planning for bipedal humanoids requires careful consideration of balance, kinematic constraints, and gait patterns to ensure safe and effective navigation in real-world environments."})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);